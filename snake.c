//******************************************************************************
//  Lab 4
//
//  Description: Sample the two axis accelerometer and show results 
//               on LCD
//
//	
//   Gustavo Litovsky
//   The University of Texas at Dallas
//   Some code Copyright 2008 Texas Instruments, Inc.
//   July 2010
//   Built with CCS Version: 
//******************************************************************************

#include "msp430x54xA.h"
#include "hal_lcd.h"
#include "board_defs.h"
#include "in430.h"
#include "intrinsics.h"
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

#define GAMESIZE 117
#define BOARDSIZE 20
#define RIGHTMOST 137
#define LOWERMOST 109
#define SNAKESIZE 2
#define UP        0
#define RIGHT     1
#define DOWN      2
#define LEFT      3
#define INITIALSIZE 5

void displayRotation(signed int x, signed int y);
void halBoardStartXT1(void);
void halBoardSetSystemClock(unsigned char systemClockSpeed);
static void halBoardGetSystemClockSettings(unsigned char systemClockSpeed, 
                                           unsigned char *setDcoRange,
                                           unsigned char *setVCore,
                                           unsigned int  *setMultiplier);
void uartInit(void);
char uartBuffer[255];
//void uartByte(char byte);
//void uartString(char string[], unsigned char length);

void drawHomeScreen();
void drawSnakePos();

//for game
void gameInit();
void userInput();
void generateWallsAndApples();
void moveSnake();
void collisionDetection();

__no_init unsigned char lcdBackLightLevelSetting @ 0x1908;
unsigned char lcdBackLightLevelSetting;
unsigned char lcdContrastSetting;
unsigned char lcdBackLightLevelSettingLOCAL;
unsigned char lcdContrastSettingLOCAL;


//variable declaration
char status, dir, level, homescreen, numplayers, snakepos, accl;
int apples;

int difficulty;

unsigned char counter = 0;

unsigned int x_axis_sample = 0;
unsigned int y_axis_sample = 0;
unsigned int z_axis_sample = 0;

#define ZERO_LVL_VAL 2048

// Each g/10 has the following increment
#define TENTH_G_VAL 42
signed int gcalcx;
signed int gcalcy;

void main(void)
{
     WDTCTL = WDTPW + WDTHOLD;           // Stop WDT
        // Allow the accelerometer to settle before sampling any data 
    // Configure button on P2.1 to cause an interrupt
  P2OUT |= BIT1;  // Configure output as High
  P2DIR &= ~BIT1; // Configure pin direction as input - overrides setting to high
  P2REN |= BIT1;  // Enable Pull-up resistor
  P2SEL &= ~BIT1; // Configure P2.1 as GPIO and not as some auxilary function
  
  // Enable interrupts for button on P2.1
  P2IES &= ~BIT1;  // flag generated by low-to-high transition
  P2IFG &= ~BIT1;  // Clear Interrupt Flag for P2.1
  P2IE  |=  BIT1;  // enable Interrupt for P2.1
  
    // Configure button on P2.1 to cause an interrupt
  P2OUT |= BIT2;  // Configure output as High
  P2DIR &= ~BIT2; // Configure pin direction as input - overrides setting to high
  P2REN |= BIT2;  // Enable Pull-up resistor
  P2SEL &= ~BIT2; // Configure P2.1 as GPIO and not as some auxilary function
  
  // Enable interrupts for button on P2.1
  P2IES &= ~BIT2;  // flag generated by low-to-high transition
  P2IFG &= ~BIT2;  // Clear Interrupt Flag for P2.6
  P2IE  |=  BIT2;  // enable Interrupt for P2.6

      // Configure button on P2.1 to cause an interrupt
  P2OUT |= BIT3;  // Configure output as High
  P2DIR &= ~BIT3; // Configure pin direction as input - overrides setting to high
  P2REN |= BIT3;  // Enable Pull-up resistor
  P2SEL &= ~BIT3; // Configure P2.1 as GPIO and not as some auxilary function
  
  // Enable interrupts for button on P2.1
  P2IES &= ~BIT3;  // flag generated by low-to-high transition
  P2IFG &= ~BIT3;  // Clear Interrupt Flag for P2.6
  P2IE  |=  BIT3;  // enable Interrupt for P2.6

  
      // Configure button on P2.1 to cause an interrupt
  P2OUT |= BIT4;  // Configure output as High
  P2DIR &= ~BIT4; // Configure pin direction as input - overrides setting to high
  P2REN |= BIT4;  // Enable Pull-up resistor
  P2SEL &= ~BIT4; // Configure P2.1 as GPIO and not as some auxilary function
  
  // Enable interrupts for button on P2.1
  P2IES &= ~BIT4;  // flag generated by low-to-high transition
  P2IFG &= ~BIT4;  // Clear Interrupt Flag for P2.6
  P2IE  |=  BIT4;  // enable Interrupt for P2.6

  
      // Configure button on P2.1 to cause an interrupt
  P2OUT |= BIT5;  // Configure output as High
  P2DIR &= ~BIT5; // Configure pin direction as input - overrides setting to high
  P2REN |= BIT5;  // Enable Pull-up resistor
  P2SEL &= ~BIT5; // Configure P2.1 as GPIO and not as some auxilary function
  
  // Enable interrupts for button on P2.1
  P2IES &= ~BIT5;  // flag generated by low-to-high transition
  P2IFG &= ~BIT5;  // Clear Interrupt Flag for P2.6
  P2IE  |=  BIT5;  // enable Interrupt for P2.6
 
    
  P6SEL |= BIT1 + BIT2;               // Enable A/D channel inputs
  P6DIR &= ~(BIT1 + BIT2 + BIT3);
  P6DIR |= BIT0;                      // Enable ACC_POWER
  P6OUT |= BIT0;
  
  // Configure the text of the buffer
  // the positions for the digits is filled later, as is the
  // name of the axis - X or Y

  //initialize timer
  TA1CCTL0 = CCIE;
  TA1CCR0 = 2159;
  TA1CTL = TASSEL_1 + MC_1 + TACLR;
  
  // Initialize clock and peripherals   
  halBoardStartXT1();	
  halBoardSetSystemClock(SYSCLK_16MHZ);
  
  lcdBackLightLevelSettingLOCAL = lcdBackLightLevelSetting;
  lcdContrastSettingLOCAL = lcdContrastSetting;
  if ( lcdContrastSettingLOCAL < 60 || lcdContrastSettingLOCAL > 128) 
      lcdContrastSettingLOCAL = 100;
  if ( lcdBackLightLevelSettingLOCAL > 15) 
      lcdBackLightLevelSettingLOCAL = 16;
  
  // Initialize LCD and backlight    
  halLcdInit();       
  halLcdBackLightInit();  
  halLcdSetBackLight(lcdBackLightLevelSettingLOCAL-2);
  halLcdSetContrast(lcdContrastSettingLOCAL+10);
  halLcdClearScreen(); 
  
  // Configure ADC to sample 3 channels, we ignore z axis 
  // Sequence of channels, once, using ACLK  
  ADC12CTL0 = ADC12ON + ADC12SHT02 + ADC12MSC;  
  ADC12CTL1 = ADC12SHP + ADC12CONSEQ_1 + ADC12SSEL_0;  
  ADC12CTL2 = ADC12RES_2;    
  ADC12MCTL0 = ADC12INCH_1;
  ADC12MCTL1 = ADC12INCH_2;
  ADC12MCTL2 = ADC12INCH_3 + ADC12EOS;

  
  uartInit();
  


  //variable initialization
  level = 1;
  homescreen = 0;
  snakepos = 0;
  accl = 0;
  apples = 0;
//  time = 0;
  dir = -1;
  
  
  drawHomeScreen();
  drawSnakePos();
  
  while(1)
  {
          //enter LPM for input
          __low_power_mode_3();
          
          if(dir==0) //"up"
                  snakepos--;
          else if(dir==2) //"down"
                  snakepos++;
  
  
          if(dir==4)  //"select"
                  {
                  //test for where snake pos is
                  if(homescreen==0) //first screen
                  {
                    if(snakepos==0) //sp selected
                                  {
                                  numplayers = 1;
                                  homescreen = 1;
                                  }
                          else if(snakepos==1) //mp selected
                                  {
                                  numplayers = 2;
                                  homescreen = 2;
                                  }
                          else if(snakepos==2)
                                  {
                                  //turn off module
                                  halLcdClearScreen();
                                  return;
                                  }
                  }
                  else if(homescreen==1) //single player screen
                  {
                    if(snakepos==0) //joystick selected
                                  {
                                  //startgame
                                  break;
                                  }
                          else if(snakepos==1) //accelerometer selected
                                  {
                                  accl = 1;
                                  //startgame
                                  break;
                                  }
                          else if(snakepos==2) //back selected
                                  homescreen = 0;
                  }
                  else if(homescreen==2) //mp selected
                          
                          //TODO: implement mp
                          homescreen=0;
  
                  drawHomeScreen();
                  
                  }
          dir = -1;
          snakepos = snakepos%3;
          drawSnakePos();
   
  }
	
	//in game
  
  UCSCTL8 |= MODOSCREQEN; 

  // Currently ADC Sampling is manual and initiated every loop iteration
  
  gameInit();
  
  while(1)
  {      
    __low_power_mode_3();
    //ingame methods
    userInput();
    generateWallsAndApples();
    moveSnake();
    collisionDetection();
  } 
}
char length;
int head_x; // Stores Head X Coordinate
int head_y; // Stores Head Y Coordinate
char head_dir; // Stores Head Direction
int tail_x; // Stores Tail X Coordinat
int tail_y; // Stores Tail Y Coordinat
char tail_dir; // Stores Tail Direction
int bend_x [100] = {-1}; //Stores X Bend Coordinate Declare it big enough to accomodate maximum bends
int bend_y [100] = {-1};
char bend_dir [100] = {-1}; // Stores Bend direction when tail reaches that X Coordinate


//In Game..


void gameInit()
{
  srand(time(NULL));
  
  halLcdClearScreen();
  head_x = RIGHTMOST / 2  + (INITIALSIZE/2 - (INITIALSIZE+1)%2);
  head_y = GAMESIZE / 2 + BOARDSIZE;
  head_dir = RIGHT;
  
  tail_x = head_x - (INITIALSIZE/2);
  tail_y = head_y;
  tail_dir = RIGHT;
  int pixelread = 0;
  for(int i = 0 ; i < INITIALSIZE ; ++i)
  {
    halLcdPixelSize(tail_x+SNAKESIZE*i, head_y, PIXEL_DARK,SNAKESIZE);
//    pixelread = halLcdReadPixel(tail_x+SNAKESIZE*i, head_y);
  } 
}

void userInput()
{
  static int i = 0;
  if( i > 100) i = 0;
  static int j = 0;
  if( j > 100) j = 0;
  
  if( head_dir % 2 != dir %2 && dir != 4)
  {
    head_dir = dir;
    bend_x[i] = head_x;
    bend_y[i] = head_y;
    bend_dir[i] = dir;
    i++;
  }
  
  if(tail_x == bend_x[j] && tail_y == bend_y[j])
  {
    tail_dir = bend_dir[j];
    j++;
  }
}

void generateWallsAndApples()
{
  if(rand() % 30 <= difficulty)
  {
    int apple_x = rand() % RIGHTMOST/2 * 2;
    int apple_y = (rand() % GAMESIZE + BOARDSIZE) / 2 * 2;
    
    //check
    halLcdPixelSize(apple_x, apple_y, PIXEL_LIGHT, SNAKESIZE);
  }
}

void moveSnake()
{
  if (head_dir == LEFT)
  {
    head_x -= SNAKESIZE;
    if(head_x < 0)
    {
      head_x = RIGHTMOST /SNAKESIZE * SNAKESIZE - SNAKESIZE;
    }
  }
  else if (head_dir == RIGHT) 
  {
    head_x += SNAKESIZE; 
    if(head_x > RIGHTMOST)
    {
      head_x = 0;
    }
  }
  else if (head_dir == UP) 
  {
    head_y -= SNAKESIZE;
    if(head_y < BOARDSIZE)
    {
      head_y = LOWERMOST /SNAKESIZE * SNAKESIZE - SNAKESIZE;
    }
  }
  else if (head_dir == DOWN) 
  {
    head_y += SNAKESIZE; 
    if(head_y > LOWERMOST)
    {
      head_y = BOARDSIZE;
    }
  }
  
  halLcdPixelSize(head_x, head_y, PIXEL_DARK, SNAKESIZE);
  halLcdPixelSize(tail_x, tail_y, PIXEL_OFF, SNAKESIZE);
  
  
  if (tail_dir == LEFT)
  {
    tail_x -= SNAKESIZE; 
  }
  if (tail_dir == RIGHT) 
  {
   tail_x += SNAKESIZE; 
  }
  if (tail_dir == UP) 
  {
   tail_y -= SNAKESIZE;
  }
  if (tail_dir == DOWN) 
  {
    tail_y += SNAKESIZE; 
  }
}

void collisionDetection()
{

}

void halBoardStartXT1(void)
{
    // Set up XT1 Pins to analog function, and to lowest drive	
    P7SEL |= 0x03;                            
    UCSCTL6 |= XCAP_3 ;                       // Set internal cap values
    
    while(SFRIFG1 & OFIFG) {                  // Check OFIFG fault flag
        while ( (SFRIFG1 & OFIFG))              // Check OFIFG fault flag
        {    
            // Clear OSC fault flags 
            UCSCTL7 &= ~(DCOFFG + XT1LFOFFG + XT1HFOFFG + XT2OFFG);
            SFRIFG1 &= ~OFIFG;                    // Clear OFIFG fault flag
        }
        UCSCTL6 &= ~(XT1DRIVE1_L+XT1DRIVE0);    // Reduce the drive strength 
    }
}

void halBoardSetSystemClock(unsigned char systemClockSpeed)
{
    unsigned char setDcoRange, setVCore;
    unsigned int  setMultiplier;
    
    halBoardGetSystemClockSettings( systemClockSpeed, &setDcoRange,  \
        &setVCore, &setMultiplier);
    
    //halBoardSetVCore( setVCore );   
    
    __bis_SR_register(SCG0);                  // Disable the FLL control loop    
    UCSCTL0 = 0x00;                           // Set lowest possible DCOx, MODx
    UCSCTL1 = setDcoRange;                    // Select suitable range
    
    UCSCTL2 = setMultiplier + FLLD_1;         // Set DCO Multiplier
    UCSCTL4 = SELA__XT1CLK | SELS__DCOCLKDIV  |  SELM__DCOCLKDIV ;
    __bic_SR_register(SCG0);                  // Enable the FLL control loop
    
    // Loop until XT1,XT2 & DCO fault flag is cleared
    do
    {
        UCSCTL7 &= ~(XT2OFFG + XT1LFOFFG + XT1HFOFFG + DCOFFG);
        // Clear XT2,XT1,DCO fault flags
        SFRIFG1 &= ~OFIFG;                      // Clear fault flags
    }while (SFRIFG1&OFIFG);                   // Test oscillator fault flag
    
    // Worst-case settling time for the DCO when the DCO range bits have been 
    // changed is n x 32 x 32 x f_FLL_reference. See UCS chapter in 5xx UG 
    // for optimization.
    // 32 x 32 x / f_FLL_reference (32,768 Hz) = .03125 = t_DCO_settle
    // t_DCO_settle / (1 / 25 MHz) = 781250 = counts_DCO_settle
    __delay_cycles(781250);  
}

static void halBoardGetSystemClockSettings(unsigned char systemClockSpeed, 
                                           unsigned char *setDcoRange,
                                           unsigned char *setVCore,
                                           unsigned int  *setMultiplier)
{
    switch (systemClockSpeed)
    {
    case SYSCLK_1MHZ: 
        *setDcoRange = DCORSEL_1MHZ;
        *setVCore = VCORE_1MHZ;
        *setMultiplier = DCO_MULT_1MHZ;
        break;
    case SYSCLK_4MHZ: 
        *setDcoRange = DCORSEL_4MHZ;
        *setVCore = VCORE_4MHZ;
        *setMultiplier = DCO_MULT_4MHZ;
        break;
    case SYSCLK_8MHZ: 
        *setDcoRange = DCORSEL_8MHZ;
        *setVCore = VCORE_8MHZ;
        *setMultiplier = DCO_MULT_8MHZ;
        break;
    case SYSCLK_12MHZ: 
        *setDcoRange = DCORSEL_12MHZ;
        *setVCore = VCORE_12MHZ;
        *setMultiplier = DCO_MULT_12MHZ;
        break;
    case SYSCLK_16MHZ: 
        *setDcoRange = DCORSEL_16MHZ;
        *setVCore = VCORE_16MHZ;
        *setMultiplier = DCO_MULT_16MHZ;
        break;
    case SYSCLK_20MHZ: 
        *setDcoRange = DCORSEL_20MHZ;
        *setVCore = VCORE_20MHZ;
        *setMultiplier = DCO_MULT_20MHZ;
        break;
    case SYSCLK_25MHZ: 
        *setDcoRange = DCORSEL_25MHZ;
        *setVCore = VCORE_25MHZ;
        *setMultiplier = DCO_MULT_25MHZ;
        break;
    }	
}
void drawHomeScreen()
{
	halLcdClearScreen();

	halLcdPrintLine("SNAKE", 0, OVERWRITE_TEXT);

	if(homescreen==0) //first screen
        {
		halLcdPrintLine("OSINGLEPLAYER", 1, OVERWRITE_TEXT);
		halLcdPrintLine(" MULTIPLAYER", 2, OVERWRITE_TEXT);
		halLcdPrintLine(" EXIT", 3, OVERWRITE_TEXT);	
        }
	else if(homescreen==1) //sp screen
	{
                halLcdPrintLine("OJOYSTICK MODE", 1, OVERWRITE_TEXT);
		halLcdPrintLine(" TILT MODE", 2, OVERWRITE_TEXT);
		halLcdPrintLine(" BACK", 3, OVERWRITE_TEXT);	
        }
	else if(homescreen==2) //mp screen
	{
                halLcdPrintLine(" BACK", 1, OVERWRITE_TEXT);
		halLcdPrintLine(" BACK", 2, OVERWRITE_TEXT);
		halLcdPrintLine(" BACK", 3, OVERWRITE_TEXT);	
  
        }
}

void drawSnakePos()
{
	if(snakepos==0)
	{
                halLcdPrintLine("O", 1, OVERWRITE_TEXT);
		halLcdPrintLine(" ", 2, OVERWRITE_TEXT);
		halLcdPrintLine(" ", 3, OVERWRITE_TEXT);
	}
        else if(snakepos==1)
	{
                halLcdPrintLine(" ", 1, OVERWRITE_TEXT);
		halLcdPrintLine("O", 2, OVERWRITE_TEXT);
		halLcdPrintLine(" ", 3, OVERWRITE_TEXT);
	}
        else if(snakepos==2)
	{
                halLcdPrintLine(" ", 1, OVERWRITE_TEXT);
		halLcdPrintLine(" ", 2, OVERWRITE_TEXT);
		halLcdPrintLine("O", 3, OVERWRITE_TEXT);
        }
}

void calcAccl()
{	
	signed int gx, gy;
	int ax, ay;
	
        // Start ADC Conversion Process
        ADC12IFG &= ~(BIT1+BIT0);                 // Clear any pending flags 
        ADC12CTL0 |=  ADC12ENC | ADC12SC ;   
        ADC12IE |= BIT2;  
        
        // Go to Low power mode to wait while conversion is ongoing
        __bis_SR_register(LPM0_bits + GIE);    
        
        // Interrupt returned here. Display data
        
        /********** Handle X-Axis **********/
        gx = x_axis_sample - ZERO_LVL_VAL;
        gx /= TENTH_G_VAL;

        
        /********** Handle Y-Axis **********/   
        gy = y_axis_sample - ZERO_LVL_VAL;
        gy /= TENTH_G_VAL;


	//get absolute values for comparison
	if(gx<0)
		ax = gx*-1;
	else
		ax = gx;
	if(gy<0)
		ay = gy*-1;
	else
		ay = gy;

	//test to make sure either gx direction is above the "threshold"
	if((ax>3)||(ay>3))
	//decide direction
	if(ax>ay)
		if(gx<0)
			dir = 3;
		else
			dir = 1;
	else
		if(gy<0)
			dir = 2;
		else
			dir = 0;
}




void uartInit(void)
{
  volatile unsigned char i;
  
  /*for (i = 0;i < 255; i++)
    uartBuffer[i]='\0';
	*/
  
  //bufferSize = 0;
  P5SEL |= BIT7 + BIT6;
  P5DIR |= BIT6;
  P5DIR &= ~BIT7;
  
  UCA1CTL1 |= UCSWRST;                          //Reset State                      
  UCA1CTL0 = UCMODE_0;
  
  UCA1CTL0 &= ~UC7BIT;                      // 8bit char
  UCA1CTL1 |= UCSSEL_2;
  UCA1BR0 = 16;                             // 8Mhz/57600=138
  UCA1BR1 = 1;
  UCA1MCTL = 0xE;
  UCA1CTL1 &= ~UCSWRST;  
  UCA1IE |= UCRXIE;
  /*
  */
  __bis_SR_register(GIE);                   // Enable Interrupts
}

//ISR for ADC
#pragma vector=ADC12_VECTOR
__interrupt void ADC12_ISR(void)
{
    // Store the sampled data 
    x_axis_sample = ADC12MEM0;             
    y_axis_sample = ADC12MEM1;
    z_axis_sample = ADC12MEM2;
    ADC12IFG = 0;                           // Clear the interrupt flags
    ADC12CTL0 &= ~( ADC12ENC | ADC12SC | ADC12REFON);     
}

//joystick ISR
#pragma vector=PORT2_VECTOR
__interrupt void Port_2(void)
{
	
  if(!accl)
	{
    	if(P2IFG & BIT1)
		dir = 3;
	else if(P2IFG & BIT2)
		dir = 1;
	else if(P2IFG & BIT3)
		dir = 4;
	else if(P2IFG & BIT4)
		dir = 0;
	else if(P2IFG & BIT5)
		dir = 2;
	}
//	else
//		dir = 4;
	__delay_cycles(20000); //debounce
        P2IFG &= 0x0; //clear IFGs   
   __low_power_mode_off_on_exit();   
}

//Timer ISR
#pragma vector=TIMER1_A0_VECTOR
__interrupt void TIMER1_A0_ISR(void)
{
  __low_power_mode_off_on_exit();
}